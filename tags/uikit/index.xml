<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>UIKit on manumateos.dev</title><link>/tags/uikit/</link><description>Recent content in UIKit on manumateos.dev</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Tue, 05 Sep 2023 19:35:34 +0200</lastBuildDate><atom:link href="/tags/uikit/index.xml" rel="self" type="application/rss+xml"/><item><title>Cómo usar fuentes personalizadas dentro de un paquete de Swift Package Manager</title><link>/posts/fuentes-personalizadas-paquete-swift-package-manager/</link><pubDate>Tue, 05 Sep 2023 19:35:34 +0200</pubDate><guid>/posts/fuentes-personalizadas-paquete-swift-package-manager/</guid><description>El proceso habitual para utilizar fuentes personalizadas en una aplicación de iOS implica añadirlas manualmente al fichero Info.plist, a un array con la clave UIAppFonts donde pondríamos todos los nombres de todos los ficheros que queramos usar, algo como JetBrainsMono-Regular.ttf. Pero la cosa cambia cuando lo que estás desarrollando está dentro de un paquete de Swift Package Manager; ahí no hay fichero donde meter las cosas.
El procedimiento es ligeramente distinto, pero se resume en:</description></item><item><title>UIKeyboardLayoutGuide</title><link>/posts/uikeyboardlayoutguide/</link><pubDate>Wed, 21 Dec 2022 16:32:35 +0100</pubDate><guid>/posts/uikeyboardlayoutguide/</guid><description>En iOS 15 se introdujo una nueva forma de hacer que nuestras aplicaciones respondan a eventos tan comunes como la aparición o desaparición de un teclado (y también a los teclados flotantes que pueden ocurrir en iPadOS). Se trata del nuevo atributo keyboardLayoutGuide que forma parte de UIView.
Lo que hace años suponía estar escuchando a una notificación y recolocar vistas (activando o desactivando constraints o, peor, modificando a mano el frame de ciertos elementos que puedan estar afectados) ahora se reduce a crear una nueva constraint que se coloque en uno de los anclas de esta layout guide, generalmente el topAnchor.</description></item><item><title>UIView.userInteractionEnabled</title><link>/posts/userinteractionenabled/</link><pubDate>Tue, 07 Dec 2021 18:18:49 +0100</pubDate><guid>/posts/userinteractionenabled/</guid><description>El parámetro userInteractionEnabled se propaga a todas las subviews. Es decir, si aplicamos a un UIView este parámetro, ninguna de sus subvistas responderán a interacciones por parte del usuario.
On iOS, if a superview&amp;rsquo;s userInteractionEnabled is NO, then all subviews are disabled as well?
Tampoco funciona si creas una subclase de UIView y sobrescribimos el método tal que así.
override func point(inside point: CGPoint, with event: UIEvent?) -&amp;gt; Bool { return false } No obstante sí que es posible usar ese mismo método y marcar zonas de la UIView que capturen el toque, y marcar zonas que no; las que no capturan el toque serán las que devuelvan false al punto point que se pasa por parámetro, y si queremos capturar el toque, devolveremos true.</description></item><item><title>UIButton.tintColor</title><link>/posts/uibutton-tintcolor/</link><pubDate>Tue, 07 Dec 2021 18:17:35 +0100</pubDate><guid>/posts/uibutton-tintcolor/</guid><description>Como bien especifica la documentación de Apple, si el UIButton es de tipo custom no va a funcionar cambiar el tintColor, sino que se va a quedar la imagen tal cual.
This property has no default effect for buttons with type UIButton.ButtonType.custom. For custom buttons, you must implement any behavior related to tintColor yourself.
El fix es tan simple como cambiar dicho UIButton a tipo system.</description></item><item><title>Ciclo de vida de los UIViewControllers</title><link>/posts/ciclo-de-vida-de-los-uiviewcontrollers/</link><pubDate>Tue, 07 Dec 2021 17:16:07 +0100</pubDate><guid>/posts/ciclo-de-vida-de-los-uiviewcontrollers/</guid><description>Un descubrimiento: en principio desde iOS 13, cuando presentas un viewController encima de otro, no se llaman los métodos viewWillDissapear ni viewDidDissapear del ViewController llamante. La solución, al menos de momento, es poner el modalPresentationStyle del viewController a mostrar, de este modo:
viewController.modalPresentationStyle = .fullScreen Split Screen Hay muchos cambios en el [[Ciclo de vida de los UIViewControllers]] en cuanto metemos en la ecuación la multitarea de iPad, particularmente la funcionalidad de #SplitScreen.</description></item></channel></rss>