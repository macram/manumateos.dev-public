<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>iOS on manumateos.dev</title><link>/tags/ios/</link><description>Recent content in iOS on manumateos.dev</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 26 May 2022 22:33:26 +0100</lastBuildDate><atom:link href="/tags/ios/index.xml" rel="self" type="application/rss+xml"/><item><title>Permitir el uso de la tecla Menú/Back en un UIAlertController</title><link>/posts/allow-menu-key-on-uialertcontroller/</link><pubDate>Thu, 26 May 2022 22:33:26 +0100</pubDate><guid>/posts/allow-menu-key-on-uialertcontroller/</guid><description>Un UIAlertController es quizá el modo más sencillo, lógico y normal de mostrar un modal en una aplicación de tvOS. Es nativo del sistema, permite colocar acciones… Es hasta razonablemente bonito.
Y si bien es sencillo tener un UIAlertController con varios botones como el de la imagen inferior, hay casos en los que podemos querer uno que sea meramente informativo o con un mensaje de “Cargando” (este caso es especialmente frecuente en apps de tvOS).</description></item><item><title>Un Apple TV no se enciende sin HDMI</title><link>/posts/apple-tv-does-not-turn-on/</link><pubDate>Wed, 27 Apr 2022 22:33:26 +0100</pubDate><guid>/posts/apple-tv-does-not-turn-on/</guid><description>Por una parte: sabéis que podéis ver desde vuestro Mac la pantalla de un Apple TV. Siempre[^ Siempre que los astros se alineen, que ya sabemos cómo funcionan a veces estas cosas.] que tengáis el Apple TV habilitado para desarrollo y en la misma red local veréis como origen de vídeo en una grabación de vídeo de Quicktime vuestro Apple TV, igual que veríais vuestra webcam o un iPhone conectado a través de cable USB.</description></item><item><title>No Space in Method Call Violation en clausura final</title><link>/posts/swiftlint-space-between-name-and-parenthesis-trailing-clausure/</link><pubDate>Mon, 21 Mar 2022 13:22:09 +0100</pubDate><guid>/posts/swiftlint-space-between-name-and-parenthesis-trailing-clausure/</guid><description>Es muy probable que en tu proyecto de app en Swift termines usando una sintaxis que incluya una clausura al final de las llamadas (por ejemplo, algún tipo de completionHandler). Esa sintaxis tiene una pinta tal que así:
method(param1: foo, param2: bar) { whatever in // Código } Esta sintaxis es análoga a esta otra.
method(param1: foo, param2: bar, completionHandler: { whatever in // Código }) Pues bien. Tras actualizar a Xcode 13.</description></item><item><title>Discover concurrency</title><link>/links/discover-concurrency/</link><pubDate>Sun, 23 Jan 2022 19:40:34 +0100</pubDate><guid>/links/discover-concurrency/</guid><description>John Sundell tiene una página que es ideal para comenzar a conocer el nuevo sistema de concurrencia de Swift (async, await y esa chufla).</description></item><item><title>Tips para reducir el número de reuniones</title><link>/links/tips-para-reducir-numero-de-reuniones/</link><pubDate>Sat, 22 Jan 2022 19:40:34 +0100</pubDate><guid>/links/tips-para-reducir-numero-de-reuniones/</guid><description>Félix López escribió un hilo de Twitter con consejos de su puño y letra teclado para reducir el número de reuniones y hacerlas más afectivas.</description></item><item><title>30 Tips to Make You a Better iOS Dev</title><link>/links/30-tips-to-make-you-a-better-ios-dev/</link><pubDate>Sun, 19 Dec 2021 19:40:34 +0100</pubDate><guid>/links/30-tips-to-make-you-a-better-ios-dev/</guid><description>Rony Fadel ha elaborado una lista (en inglés) con 30 consejos que podrían hacernos mejorar como desarrolladores iOS.</description></item><item><title>UIView.userInteractionEnabled</title><link>/posts/userinteractionenabled/</link><pubDate>Tue, 07 Dec 2021 18:18:49 +0100</pubDate><guid>/posts/userinteractionenabled/</guid><description>El parámetro userInteractionEnabled se propaga a todas las subviews. Es decir, si aplicamos a un UIView este parámetro, ninguna de sus subvistas responderán a interacciones por parte del usuario.
On iOS, if a superview&amp;rsquo;s userInteractionEnabled is NO, then all subviews are disabled as well?
Tampoco funciona si creas una subclase de UIView y sobrescribimos el método tal que así.
override func point(inside point: CGPoint, with event: UIEvent?) -&amp;gt; Bool { return false } No obstante sí que es posible usar ese mismo método y marcar zonas de la UIView que capturen el toque, y marcar zonas que no; las que no capturan el toque serán las que devuelvan false al punto point que se pasa por parámetro, y si queremos capturar el toque, devolveremos true.</description></item><item><title>UIButton.tintColor</title><link>/posts/uibutton-tintcolor/</link><pubDate>Tue, 07 Dec 2021 18:17:35 +0100</pubDate><guid>/posts/uibutton-tintcolor/</guid><description>Como bien especifica la documentación de Apple, si el UIButton es de tipo custom no va a funcionar cambiar el tintColor, sino que se va a quedar la imagen tal cual.
This property has no default effect for buttons with type UIButton.ButtonType.custom. For custom buttons, you must implement any behavior related to tintColor yourself.
El fix es tan simple como cambiar dicho UIButton a tipo system.</description></item><item><title>Obtener capturas de pantalla de un vídeo</title><link>/posts/screenshot-from-video/</link><pubDate>Tue, 07 Dec 2021 18:16:38 +0100</pubDate><guid>/posts/screenshot-from-video/</guid><description>La funcionalidad que estoy intentando implementar implica una cuestión muy concreta: necesito mostrar miniaturas de momentos aleatorios de un vídeo en streaming HLS. El ejemplo es el reproductor de YouTube: cuando se arrastra la barra atrás o adelante, se muestra una miniatura para indicar qué parte del vídeo es la afectada.
El método recomendado, en principio, es tener un AVPlayer con el rate establecido a 0, de manera que el propio AVPlayer se encargue de llevar el vídeo a esos momentos, pararlo y mostrar la imagen en la pantalla.</description></item><item><title>Símbolos en el Executable name</title><link>/posts/simbolos-executable-name/</link><pubDate>Tue, 07 Dec 2021 18:15:09 +0100</pubDate><guid>/posts/simbolos-executable-name/</guid><description>Cuando se cambia el nombre mostrado a una app de iOS, si éste tiene símbolos (p.ej Movistar+), es mejor hacerlo directamente en la clave “Bundle display name” del Info.plist, para evitar que la App Store rechace la build.
En el “Executable name” no debe haber símbolos. Y este se genera concatenando varios valores; $EXECUTABLE_PREFIX$PRODUCT_NAME$EXECUTABLE_SUFFIX. Si cambias el valor directamente en el proyecto, se establece esa variable, y al generar la build (o al subirse a TestFlight) dará error.</description></item><item><title>Doble Punto Y Coma en Localizable</title><link>/posts/doble-punto-y-coma-en-localizable/</link><pubDate>Tue, 07 Dec 2021 18:04:28 +0100</pubDate><guid>/posts/doble-punto-y-coma-en-localizable/</guid><description>Si en un fichero Localizable.strings ponemos por descuido un doble punto y coma, todas las cadenas definidas a partir de ese error no serán traducidas, y en su lugar veremos en la aplicación las claves sin traducir para esa localización concreta.</description></item><item><title>Ciclo de vida de los UIViewControllers</title><link>/posts/ciclo-de-vida-de-los-uiviewcontrollers/</link><pubDate>Tue, 07 Dec 2021 17:16:07 +0100</pubDate><guid>/posts/ciclo-de-vida-de-los-uiviewcontrollers/</guid><description>Un descubrimiento: en principio desde iOS 13, cuando presentas un viewController encima de otro, no se llaman los métodos viewWillDissapear ni viewDidDissapear del ViewController llamante. La solución, al menos de momento, es poner el modalPresentationStyle del viewController a mostrar, de este modo:
viewController.modalPresentationStyle = .fullScreen Split Screen Hay muchos cambios en el [[Ciclo de vida de los UIViewControllers]] en cuanto metemos en la ecuación la multitarea de iPad, particularmente la funcionalidad de #SplitScreen.</description></item></channel></rss>