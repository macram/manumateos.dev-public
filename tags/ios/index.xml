<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iOS on manumateos.dev</title>
    <link>/tags/ios/</link>
    <description>Recent content in iOS on manumateos.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es</language>
    <lastBuildDate>Sun, 19 Dec 2021 19:40:34 +0100</lastBuildDate><atom:link href="/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>30 Tips to Make You a Better Ios Dev</title>
      <link>/links/30-tips-to-make-you-a-better-ios-dev/</link>
      <pubDate>Sun, 19 Dec 2021 19:40:34 +0100</pubDate>
      
      <guid>/links/30-tips-to-make-you-a-better-ios-dev/</guid>
      <description>Rony Fadel ha elaborado una lista (en inglés) con 30 consejos que podrían hacernos mejorar como desarrolladores iOS.</description>
    </item>
    
    <item>
      <title>Degradados: ¿CAGradient o UIImage?</title>
      <link>/posts/cagradient-or-uiimage/</link>
      <pubDate>Sun, 19 Dec 2021 19:00:26 +0100</pubDate>
      
      <guid>/posts/cagradient-or-uiimage/</guid>
      <description>Hace unos días tuve la disyuntiva, a la hora de realizar un desarrollo de una parte de una interfaz gráfica razonablemente compleja, de si construir en tiempo de ejecución un UIImage a partir de un degradado con transparencias, o si usar directamente un CAGradientLayer, que es lo que había usado toda la vida.
Como me entró la duda, decidí investigar. El primer paso siempre es buscar en Google, y en este caso ya alguien había hecho esta misma comparación.</description>
    </item>
    
    <item>
      <title>UIView.userInteractionEnabled</title>
      <link>/posts/userinteractionenabled/</link>
      <pubDate>Tue, 07 Dec 2021 18:18:49 +0100</pubDate>
      
      <guid>/posts/userinteractionenabled/</guid>
      <description>El parámetro userInteractionEnabled se propaga a todas las subviews. Es decir, si aplicamos a un UIView este parámetro, ninguna de sus subvistas responderán a interacciones por parte del usuario.
On iOS, if a superview&amp;rsquo;s userInteractionEnabled is NO, then all subviews are disabled as well?
Tampoco funciona si creas una subclase de UIView y sobrescribimos el método tal que así.
override func point(inside point: CGPoint, with event: UIEvent?) -&amp;gt; Bool { return false } No obstante sí que es posible usar ese mismo método y marcar zonas de la UIView que capturen el toque, y marcar zonas que no; las que no capturan el toque serán las que devuelvan false al punto point que se pasa por parámetro, y si queremos capturar el toque, devolveremos true.</description>
    </item>
    
    <item>
      <title>UIButton.tintColor</title>
      <link>/posts/uibutton-tintcolor/</link>
      <pubDate>Tue, 07 Dec 2021 18:17:35 +0100</pubDate>
      
      <guid>/posts/uibutton-tintcolor/</guid>
      <description>Como bien especifica la documentación de Apple, si el UIButton es de tipo custom no va a funcionar cambiar el tintColor, sino que se va a quedar la imagen tal cual.
 This property has no default effect for buttons with type UIButton.ButtonType.custom. For custom buttons, you must implement any behavior related to tintColor yourself.
 El fix es tan simple como cambiar dicho UIButton a tipo system.</description>
    </item>
    
    <item>
      <title>Obtener capturas de pantalla de un vídeo</title>
      <link>/posts/screenshot-from-video/</link>
      <pubDate>Tue, 07 Dec 2021 18:16:38 +0100</pubDate>
      
      <guid>/posts/screenshot-from-video/</guid>
      <description>La funcionalidad que estoy intentando implementar implica una cuestión muy concreta: necesito mostrar miniaturas de momentos aleatorios de un vídeo en streaming HLS. El ejemplo es el reproductor de YouTube: cuando se arrastra la barra atrás o adelante, se muestra una miniatura para indicar qué parte del vídeo es la afectada.
El método recomendado, en principio, es tener un AVPlayer con el rate establecido a 0, de manera que el propio AVPlayer se encargue de llevar el vídeo a esos momentos, pararlo y mostrar la imagen en la pantalla.</description>
    </item>
    
    <item>
      <title>Símbolos en el Executable name</title>
      <link>/posts/simbolos-executable-name/</link>
      <pubDate>Tue, 07 Dec 2021 18:15:09 +0100</pubDate>
      
      <guid>/posts/simbolos-executable-name/</guid>
      <description>Cuando se cambia el nombre mostrado a una app de iOS, si éste tiene símbolos (p.ej Movistar+), es mejor hacerlo directamente en la clave “Bundle display name” del Info.plist, para evitar que la App Store rechace la build.
En el “Executable name” no debe haber símbolos. Y este se genera concatenando varios valores; $EXECUTABLE_PREFIX$PRODUCT_NAME$EXECUTABLE_SUFFIX. Si cambias el valor directamente en el proyecto, se establece esa variable, y al generar la build (o al subirse a TestFlight) dará error.</description>
    </item>
    
    <item>
      <title>Doble Punto Y Coma en Localizable</title>
      <link>/posts/doble-punto-y-coma-en-localizable/</link>
      <pubDate>Tue, 07 Dec 2021 18:04:28 +0100</pubDate>
      
      <guid>/posts/doble-punto-y-coma-en-localizable/</guid>
      <description>Si en un fichero Localizable.strings ponemos por descuido un doble punto y coma, todas las cadenas definidas a partir de ese error no serán traducidas, y en su lugar veremos en la aplicación las claves sin traducir para esa localización concreta.</description>
    </item>
    
    <item>
      <title>Ciclo de vida de los UIViewControllers</title>
      <link>/posts/ciclo-de-vida-de-los-uiviewcontrollers/</link>
      <pubDate>Tue, 07 Dec 2021 17:16:07 +0100</pubDate>
      
      <guid>/posts/ciclo-de-vida-de-los-uiviewcontrollers/</guid>
      <description>Un descubrimiento: en principio desde iOS 13, cuando presentas un viewController encima de otro, no se llaman los métodos viewWillDissapear ni viewDidDissapear del ViewController llamante. La solución, al menos de momento, es poner el modalPresentationStyle del viewController a mostrar, de este modo:
viewController.modalPresentationStyle = .fullScreen Split Screen Hay muchos cambios en el [[Ciclo de vida de los UIViewControllers]] en cuanto metemos en la ecuación la multitarea de iPad, particularmente la funcionalidad de #SplitScreen.</description>
    </item>
    
  </channel>
</rss>
