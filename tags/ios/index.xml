<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>iOS on mánumateos.dev</title><link>/tags/ios/</link><description>Recent content in iOS on mánumateos.dev</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Mon, 13 Nov 2023 16:24:09 +0100</lastBuildDate><atom:link href="/tags/ios/index.xml" rel="self" type="application/rss+xml"/><item><title>Comunicar Xcode 14 con un dispositivo con iOS 17</title><link>/posts/ios-17-xcode-14/</link><pubDate>Mon, 13 Nov 2023 16:24:09 +0100</pubDate><guid>/posts/ios-17-xcode-14/</guid><description>A todos nos ha pasado alguna vez: hemos tenido que conectar un iPhone actualizado a una versión de Xcode más antigua. Y hasta hace no mucho muchos acabábamos utilizando la herramienta de iGhibli para instalar los archivos de soporte.
Pero hoy he intentado hacerlo para poder compilar en mi iPhone con iOS 17 desde Xcode 14, y resulta que los ficheros de soporte para esta versión del sistema operativo no existen.</description></item><item><title>Cómo usar fuentes personalizadas dentro de un paquete de Swift Package Manager</title><link>/posts/fuentes-personalizadas-paquete-swift-package-manager/</link><pubDate>Tue, 05 Sep 2023 19:35:34 +0200</pubDate><guid>/posts/fuentes-personalizadas-paquete-swift-package-manager/</guid><description>El proceso habitual para utilizar fuentes personalizadas en una aplicación de iOS implica añadirlas manualmente al fichero Info.plist, a un array con la clave UIAppFonts donde pondríamos todos los nombres de todos los ficheros que queramos usar, algo como JetBrainsMono-Regular.ttf. Pero la cosa cambia cuando lo que estás desarrollando está dentro de un paquete de Swift Package Manager; ahí no hay fichero donde meter las cosas.
El procedimiento es ligeramente distinto, pero se resume en:</description></item><item><title>Reducir el uso de CPU de Google Maps</title><link>/posts/google-maps-sdk-uso-cpu/</link><pubDate>Fri, 18 Aug 2023 16:10:34 +0100</pubDate><guid>/posts/google-maps-sdk-uso-cpu/</guid><description>En una pantalla con un mapa que utiliza el SDK de Google Maps es probable que, si tienes muchos marcadores con una iconView, experimentes un gran uso de CPU. Esto entiendo que es debido fundamentalmente al repintado de estas vistas en cada uno de los frames.
La solución rápida para solucionarlo, o al menos mitigarlo, es establecer a false la propiedad tracksViewChanges. Eso sí, si vas a animar la vista (por ejemplo en el momento de aparecer, o al pulsarlas) será necesario que establezcas esa propiedad a true al comenzar la animación y a false justo al finalizar.</description></item><item><title>UIKeyboardLayoutGuide</title><link>/posts/uikeyboardlayoutguide/</link><pubDate>Wed, 21 Dec 2022 16:32:35 +0100</pubDate><guid>/posts/uikeyboardlayoutguide/</guid><description>En iOS 15 se introdujo una nueva forma de hacer que nuestras aplicaciones respondan a eventos tan comunes como la aparición o desaparición de un teclado (y también a los teclados flotantes que pueden ocurrir en iPadOS). Se trata del nuevo atributo keyboardLayoutGuide que forma parte de UIView.
Lo que hace años suponía estar escuchando a una notificación y recolocar vistas (activando o desactivando constraints o, peor, modificando a mano el frame de ciertos elementos que puedan estar afectados) ahora se reduce a crear una nueva constraint que se coloque en uno de los anclas de esta layout guide, generalmente el topAnchor.</description></item><item><title>Permitir el uso de la tecla Menú/Back en un UIAlertController</title><link>/posts/allow-menu-key-on-uialertcontroller/</link><pubDate>Thu, 26 May 2022 22:33:26 +0100</pubDate><guid>/posts/allow-menu-key-on-uialertcontroller/</guid><description>Un UIAlertController es quizá el modo más sencillo, lógico y normal de mostrar un modal en una aplicación de tvOS. Es nativo del sistema, permite colocar acciones… Es hasta razonablemente bonito.
Y si bien es sencillo tener un UIAlertController con varios botones como el de la imagen inferior, hay casos en los que podemos querer uno que sea meramente informativo o con un mensaje de “Cargando” (este caso es especialmente frecuente en apps de tvOS).</description></item><item><title>Un Apple TV no se enciende sin HDMI</title><link>/posts/apple-tv-does-not-turn-on/</link><pubDate>Wed, 27 Apr 2022 22:33:26 +0100</pubDate><guid>/posts/apple-tv-does-not-turn-on/</guid><description>Por una parte: sabéis que podéis ver desde vuestro Mac la pantalla de un Apple TV. Siempre[^ Siempre que los astros se alineen, que ya sabemos cómo funcionan a veces estas cosas.] que tengáis el Apple TV habilitado para desarrollo y en la misma red local veréis como origen de vídeo en una grabación de vídeo de Quicktime vuestro Apple TV, igual que veríais vuestra webcam o un iPhone conectado a través de cable USB.</description></item><item><title>No Space in Method Call Violation en clausura final</title><link>/posts/swiftlint-space-between-name-and-parenthesis-trailing-clausure/</link><pubDate>Mon, 21 Mar 2022 13:22:09 +0100</pubDate><guid>/posts/swiftlint-space-between-name-and-parenthesis-trailing-clausure/</guid><description>Es muy probable que en tu proyecto de app en Swift termines usando una sintaxis que incluya una clausura al final de las llamadas (por ejemplo, algún tipo de completionHandler). Esa sintaxis tiene una pinta tal que así:
method(param1: foo, param2: bar) { whatever in // Código } Esta sintaxis es análoga a esta otra.
method(param1: foo, param2: bar, completionHandler: { whatever in // Código }) Pues bien. Tras actualizar a Xcode 13.</description></item><item><title>Discover concurrency</title><link>/posts/discover-concurrency/</link><pubDate>Sun, 23 Jan 2022 19:40:34 +0100</pubDate><guid>/posts/discover-concurrency/</guid><description>John Sundell tiene una página que es ideal para comenzar a conocer el nuevo sistema de concurrencia de Swift (async, await y esa chufla).</description></item><item><title>30 Tips to Make You a Better iOS Dev</title><link>/posts/30-tips-to-make-you-a-better-ios-dev/</link><pubDate>Sun, 19 Dec 2021 19:40:34 +0100</pubDate><guid>/posts/30-tips-to-make-you-a-better-ios-dev/</guid><description>Rony Fadel ha elaborado una lista (en inglés) con 30 consejos que podrían hacernos mejorar como desarrolladores iOS.</description></item><item><title>UIView.userInteractionEnabled</title><link>/posts/userinteractionenabled/</link><pubDate>Tue, 07 Dec 2021 18:18:49 +0100</pubDate><guid>/posts/userinteractionenabled/</guid><description>El parámetro userInteractionEnabled se propaga a todas las subviews. Es decir, si aplicamos a un UIView este parámetro, ninguna de sus subvistas responderán a interacciones por parte del usuario.
On iOS, if a superview&amp;rsquo;s userInteractionEnabled is NO, then all subviews are disabled as well?
Tampoco funciona si creas una subclase de UIView y sobrescribimos el método tal que así.
override func point(inside point: CGPoint, with event: UIEvent?) -&amp;gt; Bool { return false } No obstante sí que es posible usar ese mismo método y marcar zonas de la UIView que capturen el toque, y marcar zonas que no; las que no capturan el toque serán las que devuelvan false al punto point que se pasa por parámetro, y si queremos capturar el toque, devolveremos true.</description></item><item><title>UIButton.tintColor</title><link>/posts/uibutton-tintcolor/</link><pubDate>Tue, 07 Dec 2021 18:17:35 +0100</pubDate><guid>/posts/uibutton-tintcolor/</guid><description>Como bien especifica la documentación de Apple, si el UIButton es de tipo custom no va a funcionar cambiar el tintColor, sino que se va a quedar la imagen tal cual.
This property has no default effect for buttons with type UIButton.ButtonType.custom. For custom buttons, you must implement any behavior related to tintColor yourself.
El fix es tan simple como cambiar dicho UIButton a tipo system.</description></item><item><title>Obtener capturas de pantalla de un vídeo</title><link>/posts/screenshot-from-video/</link><pubDate>Tue, 07 Dec 2021 18:16:38 +0100</pubDate><guid>/posts/screenshot-from-video/</guid><description>La funcionalidad que estoy intentando implementar implica una cuestión muy concreta: necesito mostrar miniaturas de momentos aleatorios de un vídeo en streaming HLS. El ejemplo es el reproductor de YouTube: cuando se arrastra la barra atrás o adelante, se muestra una miniatura para indicar qué parte del vídeo es la afectada.
El método recomendado, en principio, es tener un AVPlayer con el rate establecido a 0, de manera que el propio AVPlayer se encargue de llevar el vídeo a esos momentos, pararlo y mostrar la imagen en la pantalla.</description></item><item><title>Símbolos en el Executable name</title><link>/posts/simbolos-executable-name/</link><pubDate>Tue, 07 Dec 2021 18:15:09 +0100</pubDate><guid>/posts/simbolos-executable-name/</guid><description>Cuando se cambia el nombre mostrado a una app de iOS, si éste tiene símbolos (p.ej Movistar+), es mejor hacerlo directamente en la clave “Bundle display name” del Info.plist, para evitar que la App Store rechace la build.
En el “Executable name” no debe haber símbolos. Y este se genera concatenando varios valores; $EXECUTABLE_PREFIX$PRODUCT_NAME$EXECUTABLE_SUFFIX. Si cambias el valor directamente en el proyecto, se establece esa variable, y al generar la build (o al subirse a TestFlight) dará error.</description></item><item><title>Doble Punto Y Coma en Localizable</title><link>/posts/doble-punto-y-coma-en-localizable/</link><pubDate>Tue, 07 Dec 2021 18:04:28 +0100</pubDate><guid>/posts/doble-punto-y-coma-en-localizable/</guid><description>Si en un fichero Localizable.strings ponemos por descuido un doble punto y coma, todas las cadenas definidas a partir de ese error no serán traducidas, y en su lugar veremos en la aplicación las claves sin traducir para esa localización concreta.</description></item><item><title>Ciclo de vida de los UIViewControllers</title><link>/posts/ciclo-de-vida-de-los-uiviewcontrollers/</link><pubDate>Tue, 07 Dec 2021 17:16:07 +0100</pubDate><guid>/posts/ciclo-de-vida-de-los-uiviewcontrollers/</guid><description>Un descubrimiento: en principio desde iOS 13, cuando presentas un viewController encima de otro, no se llaman los métodos viewWillDissapear ni viewDidDissapear del ViewController llamante. La solución, al menos de momento, es poner el modalPresentationStyle del viewController a mostrar, de este modo:
viewController.modalPresentationStyle = .fullScreen Split Screen Hay muchos cambios en el [[Ciclo de vida de los UIViewControllers]] en cuanto metemos en la ecuación la multitarea de iPad, particularmente la funcionalidad de #SplitScreen.</description></item></channel></rss>