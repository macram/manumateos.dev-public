<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=es><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Obtener capturas de pantalla de un vídeo - manumateos.dev</title><meta name=theme-color><meta name=description content="La funcionalidad que estoy intentando implementar implica una cuestión muy concreta: necesito mostrar miniaturas de momentos aleatorios de un vídeo en streaming HLS. El ejemplo es el reproductor de YouTube: cuando se arrastra la barra atrás o adelante, se muestra una miniatura para indicar qué parte del vídeo es la afectada.
El método recomendado, en principio, es tener un AVPlayer con el rate establecido a 0, de manera que el propio AVPlayer se encargue de llevar el vídeo a esos momentos, pararlo y mostrar la imagen en la pantalla."><meta name=author content="manumateos.dev"><link rel="preload stylesheet" as=style href=/main.min.css><link rel=preload as=image href=/theme.png><link rel=preload as=image href=/github.svg><link rel=preload as=image href=/linkedin.svg><link rel=preload as=image href=/mastodon.svg><link rel=preload as=image href=/rss.svg><script defer src=/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=/favicon.ico><link rel=apple-touch-icon href=/apple-touch-icon.png><meta name=generator content="Hugo 0.118.2"><meta itemprop=name content="Obtener capturas de pantalla de un vídeo"><meta itemprop=description content="La funcionalidad que estoy intentando implementar implica una cuestión muy concreta: necesito mostrar miniaturas de momentos aleatorios de un vídeo en streaming HLS. El ejemplo es el reproductor de YouTube: cuando se arrastra la barra atrás o adelante, se muestra una miniatura para indicar qué parte del vídeo es la afectada.
El método recomendado, en principio, es tener un AVPlayer con el rate establecido a 0, de manera que el propio AVPlayer se encargue de llevar el vídeo a esos momentos, pararlo y mostrar la imagen en la pantalla."><meta itemprop=datePublished content="2021-12-07T18:16:38+01:00"><meta itemprop=dateModified content="2021-12-07T18:16:38+01:00"><meta itemprop=wordCount content="243"><meta itemprop=keywords content="AVKit,iOS,"><meta property="og:title" content="Obtener capturas de pantalla de un vídeo"><meta property="og:description" content="La funcionalidad que estoy intentando implementar implica una cuestión muy concreta: necesito mostrar miniaturas de momentos aleatorios de un vídeo en streaming HLS. El ejemplo es el reproductor de YouTube: cuando se arrastra la barra atrás o adelante, se muestra una miniatura para indicar qué parte del vídeo es la afectada.
El método recomendado, en principio, es tener un AVPlayer con el rate establecido a 0, de manera que el propio AVPlayer se encargue de llevar el vídeo a esos momentos, pararlo y mostrar la imagen en la pantalla."><meta property="og:type" content="article"><meta property="og:url" content="/posts/screenshot-from-video/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-07T18:16:38+01:00"><meta property="article:modified_time" content="2021-12-07T18:16:38+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Obtener capturas de pantalla de un vídeo"><meta name=twitter:description content="La funcionalidad que estoy intentando implementar implica una cuestión muy concreta: necesito mostrar miniaturas de momentos aleatorios de un vídeo en streaming HLS. El ejemplo es el reproductor de YouTube: cuando se arrastra la barra atrás o adelante, se muestra una miniatura para indicar qué parte del vídeo es la afectada.
El método recomendado, en principio, es tener un AVPlayer con el rate establecido a 0, de manera que el propio AVPlayer se encargue de llevar el vídeo a esos momentos, pararlo y mostrar la imagen en la pantalla."><link rel=canonical href=/posts/screenshot-from-video/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=/>manumateos.dev</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/>home</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/sobre-mi/>sobre mí</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tags/>tags</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/macram target=_blank rel=me>github</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./linkedin.svg) href=https://linkedin.com/in/https://es.linkedin.com/in/manumateos target=_blank rel=me>linkedin</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./mastodon.svg) href=https://paquita.masto.host/@manu target=_blank rel=me>mastodon</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5"><span aria-hidden=true>&#128221;</span>
Obtener capturas de pantalla de un vídeo</h1><div class="text-sm opacity-50"><time><a href=/posts/screenshot-from-video/>Dec 7, 2021</a></time></div></header><section><p>La funcionalidad que estoy intentando implementar implica una cuestión muy concreta: necesito mostrar miniaturas de momentos aleatorios de un vídeo en streaming HLS. El ejemplo es el reproductor de YouTube: cuando se arrastra la barra atrás o adelante, se muestra una miniatura para indicar qué parte del vídeo es la afectada.</p><p>El método recomendado, en principio, es <strong>tener un AVPlayer con el rate establecido a 0</strong>, de manera que el propio AVPlayer se encargue de llevar el vídeo a esos momentos, pararlo y mostrar la imagen en la pantalla. Ese player ya puede estar incrustado en cualquier AVPlayerViewController (y la view de este controller, como una subview de cualquier otra vista), sin ningún problema.</p><p><a href=https://stackoverflow.com/questions/54617558/failed-to-get-video-thumbnail-from-avplayer-using-fairplay-hls>Failed to get video thumbnail from AVPlayer using Fairplay HLS</a></p><h2 id=avassetimagegenerator>AVAssetImageGenerator</h2><p>El método <strong><a href=https://developer.apple.com/documentation/avfoundation/avassetimagegenerator/1387303-copycgimage><code>AVAssetImageGenerator.copyCGImageAtTime</code></a></strong> en principio debería funcionar, pero aparentemente no genera resultados para <em>assets</em> que sean remotos y no locales. No descarto que el problema estuviera relacionado con el DRM que utilizan los streams que manejo, y que en ese momento no estaba tratando de ninguna manera.</p><p><a href=https://medium.com/@PaulWall43/generating-video-thumnails-at-runtime-in-ios-swift-a2b092301c9a>Generating Video Thumbnails at Runtime in iOS (Swift)</a></p><p>Además, tendría una penalización de rendimiento bastante fuerte (el método funciona de manera síncrona; para este caso habría que generar determinadas capturas en segundo plano y cachearlas de alguna manera).</p><p>Este método podría servir para tener marcas de capítulos, pero para ir generando capturas en vivo, que es el caso que necesito resolver. Habría otro método específico que podría servir todavía mejor: <code>[generateCGImagesAsynchronously(forTimes:completionHandler:)](https://developer.apple.com/documentation/avfoundation/avassetimagegenerator/1388100-generatecgimagesasynchronously)</code>.</p></section><footer class="mt-12 flex flex-wrap"><a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=/tags/avkit>AVKit</a>
<a class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]" href=/tags/ios>iOS</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/posts/uibutton-tintcolor/><span class=mr-1.5>←</span><span>UIButton.tintColor</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/posts/simbolos-executable-name/><span>Símbolos en el Executable name</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=/>manumateos.dev</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>